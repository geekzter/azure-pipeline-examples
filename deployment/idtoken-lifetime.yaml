parameters:
- name: intervalMinutes
  displayName: Interval (minutes)
  type: number
  default: 1
- name: maxMinutes
  displayName: Maximum time (minutes)
  type: number
  default: 90
- name: pool
  displayName: Agent pool
  default: 'Azure Pipelines'
- name: vmImage
  displayName: Agent image
  default: 'ubuntu-latest'

name: $(Date:yyyyMMdd)$(Rev:.r)-$(Build.DefinitionVersion)-$(SourceBranchName)-${{ parameters.intervalMinutes }}-${{ parameters.maxMinutes }}-$(Build.BuildId)
trigger: none

jobs:
# - job: azSession
#   displayName: 'az account show'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:

  # - task: AzureCLI@2
  #   displayName: '$(subscriptionConnection) info'
  #   inputs:
  #     azureSubscription: $(subscriptionConnection)
  #     failOnStandardError: true
  #     powerShellIgnoreLASTEXITCODE: false
  #     powerShellErrorActionPreference: Stop
  #     scriptType: pscore
  #     scriptLocation: inlineScript
  #     inlineScript: |
  #       Write-Host "Service Connection Name: $(subscriptionConnection)"

  #       Get-ChildItem -Path Env: -Recurse -Include ENDPOINT_DATA_* | Sort-Object -Property Name `
  #                                                                  | Select-Object -First 1 -ExpandProperty Name `
  #                                                                  | ForEach-Object { $_ -replace 'ENDPOINT_DATA_','' } `
  #                                                                  | Set-Variable serviceConnectionId
  #       Write-Host "Service Connection id: ${serviceConnectionId}"
  #       "Service Connection url: {0}{1}/_settings/adminservices?resourceId={2}" -f $env:SYSTEM_COLLECTIONURI, $env:SYSTEM_TEAMPROJECTID, $serviceConnectionId | Write-Host

  # - task: AzureCLI@2
  #   displayName: 'az account show with $(subscriptionConnection)'
  #   inputs:
  #     azureSubscription: $(subscriptionConnection)
  #     failOnStandardError: true
  #     powerShellIgnoreLASTEXITCODE: false
  #     powerShellErrorActionPreference: Stop
  #     scriptType: pscore
  #     scriptLocation: inlineScript
  #     inlineScript: |
  #       $stopwatch = [system.diagnostics.stopwatch]::StartNew()
  #       do {
  #         if (!(az account show 2>$null)) {
  #           Write-Host "##vso[task.logissue type=error]Session expired after $($stopwatch.Elapsed.TotalMinutes) minutes"
  #           exit 1
  #         }

  #         Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
  #         Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
  #       } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

# - job: azLogin
#   displayName: 'az login'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:
#   - task: AzureCLI@2
#     displayName: 'az login with $(subscriptionConnection)'
#     inputs:
#       addSpnToEnvironment: true
#       azureSubscription: $(subscriptionConnection)
#       failOnStandardError: true
#       powerShellIgnoreLASTEXITCODE: false
#       powerShellErrorActionPreference: Stop
#       scriptType: pscore
#       scriptLocation: inlineScript
#       inlineScript: |
#         if (!$env:idToken) {
#           Write-Host "##vso[task.logissue type=warning]idToken not available"
#           exit
#         }

#         az account show 2>$null | ConvertFrom-Json | Set-Variable serviceConnection

#         $stopwatch = [system.diagnostics.stopwatch]::StartNew()
#         do {
#           Write-Host "`nLogging out.."
#           az logout 

#           Write-Host "`nLog back in with federated token.."
#           az login --service-principal -u $serviceConnection.user.name --tenant $serviceConnection.tenantId --allow-no-subscriptions --federated-token $env:idToken
#           if (!(az account show 2>$null)) {
#             Write-Host "##vso[task.logissue type=error]Token expired after $($stopwatch.Elapsed.TotalMinutes) minutes"
#             exit 1
#           }

#           Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
#           Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
#         } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))
# - job: azAccessToken
#   displayName: 'az account get-access-token'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:
#   - task: AzureCLI@2
#     displayName: 'az account get-access-token with $(subscriptionConnection)'
#     inputs:
#       azureSubscription: $(subscriptionConnection)
#       failOnStandardError: true
#       powerShellIgnoreLASTEXITCODE: false
#       powerShellErrorActionPreference: Stop
#       scriptType: pscore
#       scriptLocation: inlineScript
#       inlineScript: |
#         $stopwatch = [system.diagnostics.stopwatch]::StartNew()
#         do {
#           $expiresOn = $null
#           # $resource = '499b84ac-1321-427f-aa17-267ca6975798' # Azure DevOps
#           $resource = 'https://kusto.kusto.windows.net'
#           Write-Host "`nRequesting access token for '${resource}'.."
#           az account get-access-token --resource $resource `
#                                       --query "expiresOn" `
#                                       --output tsv `
#                                       | Set-Variable expiresOn
#           if ($expiresOn) {
#             Write-Host "Access token expires in $([math]::Round(([DateTime]::Parse($expiresOn) - [DateTime]::Now).TotalMinutes)) minutes"            
#           } else {
#             Write-Host "##vso[task.logissue type=error]Could not get access token"
#             exit 1
#           }

#           Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
#           Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
#         } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

# - job: pwshSession
#   displayName: 'Get-AzContext'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:
#   - task: AzurePowerShell@5
#     name: imageBuild
#     displayName: 'Get-AzContext'
#     inputs:
#       azureSubscription: '$(subscriptionConnection)'
#       scriptType: inlineScript
#       inline: |
#         $stopwatch = [system.diagnostics.stopwatch]::StartNew()
#         do {
#           if (!(Get-AzContext -ErrorAction SilentlyContinue)) {
#             Write-Host "##vso[task.logissue type=error]Session expired after $($stopwatch.Elapsed.TotalMinutes) minutes"
#             Get-AzContext
#             exit 1
#           } else {
#             Get-AzContext
#           }

#           Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
#           Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
#         } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

#       azurePowerShellVersion: 'latestVersion'
#       pwsh: true
#       failOnStandardError: true

# - job: pwshSessionToken
#   displayName: 'Get-AzAccessToken'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:
#   - task: AzurePowerShell@5
#     name: imageBuild
#     displayName: 'Get-AzAccessToken'
#     inputs:
#       azureSubscription: '$(subscriptionConnection)'
#       scriptType: inlineScript
#       inline: |
#         $stopwatch = [system.diagnostics.stopwatch]::StartNew()
#         do {
#           $token = $null
#           Get-AzAccessToken -ErrorAction SilentlyContinue `
#                             | Select-Object -ExcludeProperty Token `
#                             | Tee-Object -Variable token `
#                             | Format-List
#           if ($token) {
#             $remainingMinutes = ($token.ExpiresOn - [DateTime]::Now).TotalMinutes
#             if ($remainingMinutes -lt 5) {
#               Write-Host "##vso[task.logissue type=warning]Access token expires in only $remainingMinutes minutes" 
#               exit 1
#             }
#             Write-Host "Access token expires in $remainingMinutes minutes"            
#           } else {
#             Write-Host "##vso[task.logissue type=error]Could not get access token"
#             exit 1
#           }

#           Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
#           Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
#         } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

#       azurePowerShellVersion: 'latestVersion'
#       pwsh: true
#       failOnStandardError: true

# - job: pwshAccessToken
#   displayName: 'Get-AzAccessToken -ResourceUrl'
#   pool:
#     name: ${{ parameters.pool }}
#     vmImage: ${{ parameters.vmImage }}
#   timeoutInMinutes: ${{ parameters.maxMinutes }}
#   steps:
#   - task: AzurePowerShell@5
#     name: imageBuild
#     displayName: 'Get-AzAccessToken -ResourceUrl'
#     inputs:
#       azureSubscription: '$(subscriptionConnection)'
#       scriptType: inlineScript
#       inline: |
#         $stopwatch = [system.diagnostics.stopwatch]::StartNew()
#         do {
#           $expiresOn = $null
#           $resource = '499b84ac-1321-427f-aa17-267ca6975798' # Azure DevOps
#           # $resource = 'https://kusto.kusto.windows.net'
#           Write-Host "`nRequesting access token for '${resource}'.."
#           $token = $null
#           Get-AzAccessToken -ErrorAction SilentlyContinue `
#                             -ResourceUrl $resource `
#                             | Select-Object -ExcludeProperty Token `
#                             | Tee-Object -Variable token `
#                             | Format-List
#           if ($token) {
#             $remainingMinutes = ($token.ExpiresOn - [DateTime]::Now).TotalMinutes
#             if ($remainingMinutes -lt 5) {
#               Write-Host "##vso[task.logissue type=warning]Access token expires in only $remainingMinutes minutes" 
#               exit 1
#             }
#             Write-Host "Access token expires in $remainingMinutes minutes"            
#           } else {
#             Write-Host "##vso[task.logissue type=error]Could not get access token"
#             exit 1
#           }

#           Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
#           Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
#         } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

#       azurePowerShellVersion: 'latestVersion'
#       pwsh: true
#       failOnStandardError: true

- job: pwshAccessTokenWithRefresh
  displayName: 'Get-AzAccessToken -ResourceUrl (with idToken refresh)'
  pool:
    name: ${{ parameters.pool }}
    vmImage: ${{ parameters.vmImage }}
  timeoutInMinutes: ${{ parameters.maxMinutes }}
  steps:
  - task: AzurePowerShell@5
    name: imageBuild
    displayName: 'Get-AzAccessToken -ResourceUrl (with idToken refresh)'
    inputs:
      azureSubscription: '$(subscriptionConnection)'
      scriptType: inlineScript
      inline: |
        if ($env:SYSTEM_DEBUG -eq "true") {
          Set-PSDebug -Trace 2

          $InformationPreference = "Continue"
          $VerbosePreference = "Continue"
          $DebugPreference = "Continue"
        }

        # function Refresh-OidcToken() {
        #   if ($env:SYSTEM_DEBUG -eq "true") {
        #     Set-PSDebug -Trace 2

        #     $InformationPreference = "Continue"
        #     $VerbosePreference = "Continue"
        #     $DebugPreference = "Continue"
        #   }

        #   # Request fresh idToken
        #   Write-Debug "Determining service connection id..."
        #   Get-ChildItem -Path Env: -Recurse -Include ENDPOINT_DATA_* | Select-Object -First 1 -ExpandProperty Name `
        #                                                               | ForEach-Object { $_.Split("_")[2] }
        #                                                               | Set-Variable serviceConnectionId
        #   Write-Debug "Service connection id: ${serviceConnectionId}"

        #   Write-Debug "Building OIDC endpoint url..."
        #   $oidcRequestUrl = "${env:SYSTEM_TEAMFOUNDATIONCOLLECTIONURI}${env:SYSTEM_TEAMPROJECTID}/_apis/distributedtask/hubs/build/plans/${env:SYSTEM_PLANID}/jobs/${env:SYSTEM_JOBID}/oidctoken?api-version=7.1-preview.1&serviceConnectionId=${serviceConnectionId}"
        #   Write-Debug "OIDC endpoint url: ${oidcRequestUrl}"
        #   Write-Debug "Requesting new OIDC token..."
        #   Invoke-RestMethod -Headers @{
        #                       Authorization  = "Bearer $(System.AccessToken)"
        #                       'Content-Type' = 'application/json'
        #                     } `
        #                     -Uri "${oidcRequestUrl}" `
        #                     -Method Post | Set-Variable oidcTokenResponse
        #   Write-Debug "OIDC token:"
        #   $oidcTokenResponse | Select-Object -ExcludeProperty oidcToken | Format-List | Out-String | Write-Debug

        #   $oidcToken = $oidcTokenResponse.oidcToken
        #   if (!$oidcToken) {
        #       throw "Could not get OIDC token"
        #   }

        #   Write-Debug "Current Azure context:"
        #   Get-AzContext | Format-List | Out-String | Write-Debug
        #   Write-Debug "Running Connect-AzAccount with freshly acquired OIDC token..."
        #   Connect-AzAccount -ApplicationId (Get-AzContext).Account.Id `
        #                     -TenantId (Get-AzContext).Tenant.Id `
        #                     -SubscriptionId (Get-AzContext).Subscription.Id `
        #                     -FederatedToken $oidcToken
        # }

        Start-Job -Name 'RefreshOidcToken' `
                  -ScriptBlock {
          do {
            # Write-Host "Sleeping for 50 minutes..."
            # Start-Sleep -Duration (New-TimeSpan -Minutes 50) 

            # Request fresh idToken
            Write-Debug "Determining service connection id..."
            Get-ChildItem -Path Env: -Recurse -Include ENDPOINT_DATA_* | Select-Object -First 1 -ExpandProperty Name `
                                                                       | ForEach-Object { $_.Split("_")[2] }
                                                                       | Set-Variable serviceConnectionId
            Write-Debug "Service connection id: ${serviceConnectionId}"

            Write-Debug "Building OIDC endpoint url..."
            $oidcRequestUrl = "${env:SYSTEM_TEAMFOUNDATIONCOLLECTIONURI}${env:SYSTEM_TEAMPROJECTID}/_apis/distributedtask/hubs/build/plans/${env:SYSTEM_PLANID}/jobs/${env:SYSTEM_JOBID}/oidctoken?api-version=7.1-preview.1&serviceConnectionId=${serviceConnectionId}"
            Write-Debug "OIDC endpoint url: ${oidcRequestUrl}"
            Write-Debug "Requesting new OIDC token..."
            Invoke-RestMethod -Headers @{
                                Authorization  = "Bearer $(System.AccessToken)"
                                'Content-Type' = 'application/json'
                              } `
                              -Uri "${oidcRequestUrl}" `
                              -Method Post | Set-Variable oidcTokenResponse
            Write-Debug "OIDC token:"
            $oidcTokenResponse | Select-Object -ExcludeProperty oidcToken | Format-List | Out-String | Write-Debug

            $oidcToken = $oidcTokenResponse.oidcToken
            if (!$oidcToken) {
                throw "Could not get OIDC token"
            }

            Write-Debug "Current Azure context:"
            Get-AzContext | Format-List | Out-String | Write-Debug
            Write-Debug "Running Connect-AzAccount with freshly acquired OIDC token..."
            Connect-AzAccount -ApplicationId (Get-AzContext).Account.Id `
                              -TenantId (Get-AzContext).Tenant.Id `
                              -SubscriptionId (Get-AzContext).Subscription.Id `
                              -FederatedToken $oidcToken

            Write-Host "Sleeping for 50 minutes..."
            Start-Sleep -Duration (New-TimeSpan -Minutes 50) 
          } while ($true)
        } | Tee-Object -Variable refreshOidcTokenJob `
          | Select-Object -ExcludeProperty Command `
          | Write-Host -ForegroundColor DarkMagenta

        $stopwatch = [system.diagnostics.stopwatch]::StartNew()
        do {
          Write-Debug "RefreshOidcToken job status ----------"
          $refreshOidcTokenJob | Receive-Job -Keep | Write-Host -ForegroundColor DarkMagenta
          Write-Debug "--------------------------------------"
          # # Request fresh idToken
          # Get-ChildItem -Path Env: -Recurse -Include ENDPOINT_DATA_* | Select-Object -First 1 -ExpandProperty Name `
          #                                                            | ForEach-Object { $_.Split("_")[2] }
          #                                                            | Set-Variable serviceConnectionId
          # $oidcRequestUrl = "${env:SYSTEM_TEAMFOUNDATIONCOLLECTIONURI}${env:SYSTEM_TEAMPROJECTID}/_apis/distributedtask/hubs/build/plans/${env:SYSTEM_PLANID}/jobs/${env:SYSTEM_JOBID}/oidctoken?api-version=7.1-preview.1&serviceConnectionId=${serviceConnectionId}"
          # Invoke-RestMethod -Headers @{
          #                     Authorization  = "Bearer $(System.AccessToken)"
          #                     'Content-Type' = 'application/json'
          #                   } `
          #                   -Uri "${oidcRequestUrl}" `
          #                   -Method Post | Set-Variable oidcTokenResponse
          # $oidcTokenResponse | Select-Object -ExcludeProperty oidcToken | Format-List
          # $oidcToken = $oidcTokenResponse.oidcToken
          # if (!$oidcToken) {
          #     throw "Could not get OIDC token"
          # }
          # Get-AzContext | Format-List
          # Connect-AzAccount -ApplicationId (Get-AzContext).Account.Id `
          #                   -TenantId (Get-AzContext).Tenant.Id `
          #                   -SubscriptionId (Get-AzContext).Subscription.Id `
          #                   -FederatedToken $oidcToken
          
          $expiresOn = $null
          $resource = '499b84ac-1321-427f-aa17-267ca6975798' # Azure DevOps
          # $resource = 'https://kusto.kusto.windows.net'
          Write-Host "`nRequesting access token for '${resource}'.."
          $token = $null
          Get-AzAccessToken -ErrorAction SilentlyContinue `
                            -ResourceUrl $resource `
                            | Select-Object -ExcludeProperty Token `
                            | Tee-Object -Variable token `
                            | Format-List
          if ($token) {
            $remainingMinutes = ($token.ExpiresOn - [DateTime]::Now).TotalMinutes
            if ($remainingMinutes -lt 5) {
              Write-Host "##vso[task.logissue type=warning]Access token expires in only $remainingMinutes minutes" 
              exit 1
            }
            Write-Host "Access token expires in $remainingMinutes minutes"            
          } else {
            Write-Host "##vso[task.logissue type=error]Could not get access token"
            exit 1
          }

          Write-Host "Elapsed time: $($stopwatch.Elapsed.TotalMinutes) minutes, sleeping for ${{ parameters.intervalMinutes }} minutes..."
          Start-Sleep -Seconds (60 * ${{ parameters.intervalMinutes }})
        } while ($stopwatch.Elapsed.TotalMinutes -lt (${{ parameters.maxMinutes }}-${{ parameters.intervalMinutes }}-1))

      azurePowerShellVersion: 'latestVersion'
      pwsh: true
      failOnStandardError: true
